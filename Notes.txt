
//----------------------------------------------------------------

    // Key/Value operations
    // list operations
    // Hash operations

    /*
    very simple text based = persistence: each line encodes a record
    Memory-> File -> dump()
    File -> Memory -> load()

    K = Key value
    L = List 
    H = Hash

    -----------------------------------------
    "example :" 
    key-value (K)
    kv_map["name"] = "Alice"
    K name Alice

    List (L)
    list_store["color"] = {"red", "blue", "orange"}
    L color red blue orange

    hahs_store["user:100"] = 
    {
        {"name":"prem"},
        {"age":"21"}
    }
        H user:100 name:prem age:21 
    -----------------------------------------

    */

    in Tcp socket programming we have 2 kernel buffers as

    give a clear info about kernel buffers and their relation with epoll triggers

Excellent question ğŸ”¥ â€” this is core Linux networking knowledge, especially for your Redis + epoll project.

Letâ€™s break it clearly and practically.

ğŸ§  1ï¸âƒ£ What Are Kernel Buffers?

When you create a TCP socket:

socket(AF_INET, SOCK_STREAM, 0);


The Linux kernel automatically creates two buffers per socket:

Buffer	Purpose
ğŸŸ¢ Receive Buffer (RX)	Stores incoming data
ğŸ”µ Send Buffer (TX)	Stores outgoing data

These are inside the kernel, not in your program.

ğŸ“¦ Receive Buffer (RX Buffer)

When client sends data:

Client â†’ Network â†’ Kernel RX Buffer â†’ Your recv()


Data first goes into the kernel receive buffer.

Only when you call:

recv()


You copy data from kernel buffer â†’ user space.

ğŸ“¤ Send Buffer (TX Buffer)

When you call:

send()


Data does NOT immediately go to network.

Instead:

Your send() â†’ Kernel TX Buffer â†’ Network â†’ Client


The kernel manages actual transmission.

ğŸ”¥ Important: send() Success â‰  Data Delivered

If send() returns success:

It only means data was placed in kernel TX buffer

It does NOT mean client received it

ğŸš€ 2ï¸âƒ£ How epoll Is Related

epoll monitors these kernel buffers.

It triggers events based on their state.

ğŸ¯ EPOLLIN (Read Event)

Triggered when:

There is data available in the RX buffer.

Meaning:

Kernel RX buffer is NOT empty


So:

epoll_wait()


returns EPOLLIN when:

recv() would not block

ğŸ¯ EPOLLOUT (Write Event)

Triggered when:

There is space available in the TX buffer.

Meaning:

Kernel TX buffer is NOT full


So:

send() would not block

ğŸ”¥ Important Behavior
RX Buffer (EPOLLIN)
RX Buffer State	EPOLLIN Triggered?
Empty	âŒ No
Has data	âœ… Yes
TX Buffer (EPOLLOUT)
TX Buffer State	EPOLLOUT Triggered?
Full	âŒ No
Has space	âœ… Yes
âš  Why EPOLLOUT Is Dangerous

TX buffer is usually not full.

That means:

ğŸ‘‰ EPOLLOUT is almost always ready
ğŸ‘‰ It keeps triggering continuously

Thatâ€™s why most servers:

Register only EPOLLIN initially

Register EPOLLOUT only when needed

ğŸ§  Real Server Pattern (Like Redis)
Step 1 â€” Register for read
events = EPOLLIN;


When client sends command â†’ EPOLLIN fires.

Step 2 â€” Process command

Generate response.

Try sending:

send()


If:

send() sends everything â†’ done


If:

send() returns EAGAIN (buffer full)


Then:

Store remaining data

Register EPOLLOUT

Step 3 â€” When EPOLLOUT fires

Send remaining data.

If finished:

Remove EPOLLOUT

Go back to only EPOLLIN

ğŸ“Œ What Happens If TX Buffer Is Full?

When TX buffer is full:

send() â†’ returns -1
errno = EAGAIN


It does NOT block (if socket is non-blocking).

You must wait for EPOLLOUT.

ğŸ”¬ Visual Diagram
CLIENT
   â†“
Network
   â†“
[ Kernel RX Buffer ] â† EPOLLIN watches this
   â†“
recv()

Your processing

send()
   â†“
[ Kernel TX Buffer ] â† EPOLLOUT watches this
   â†“
Network
   â†“
CLIENT

ğŸ§  Important For Your Redis Project

When using epoll:

âœ” You are monitoring kernel buffers
âœ” Not client buffers
âœ” Not your own memory

Events are based purely on kernel socket state.

ğŸ”¥ Why epoll Is Non-Blocking

Because:

It tells you when buffers are ready

You never block waiting

You only act when safe

Unlike multithreading where threads may block.

âš¡ Advanced: Edge Trigger vs Level Trigger
Level Trigger (default)

If RX buffer has data â†’ EPOLLIN keeps triggering.

Edge Trigger (EPOLLET)

Triggers only when state changes:

Empty â†’ Non-empty

So you must read until EAGAIN.

ğŸ¯ Summary

Kernel buffers are:

RX buffer â†’ for incoming data

TX buffer â†’ for outgoing data

epoll triggers based on:

Event	Trigger Condition
EPOLLIN	RX buffer not empty
EPOLLOUT	TX buffer not full

Since you're building a Redis clone, understanding this deeply makes you think like a real systems engineer ğŸ”¥

If you want next, I can explain:

Why real Redis uses epoll internally

How millions of connections are handled efficiently

What happens when client is slow (backpressure)

How zero-copy works in Linux networking

epoll edge triggered

Excellent ğŸ”¥ â€” now weâ€™re entering real high-performance server territory.

You asked about epoll edge triggered mode.

Letâ€™s understand it clearly and practically (especially for your Redis clone).

ğŸ“Œ 1ï¸âƒ£ What Is Edge Triggered epoll?

When using Linux epoll, there are two modes:

Mode	Flag	Behavior
Level Triggered	(default)	Repeats while condition is true
Edge Triggered	EPOLLET	Triggers only when state changes
ğŸ§  The Core Idea
ğŸŸ¢ Level Triggered (LT)

If socket RX buffer has data:

epoll keeps notifying you

Until you read everything

Safe and easy.

ğŸ”µ Edge Triggered (ET)

epoll notifies you ONLY when new data arrives.

If you donâ€™t read everything in one go:

ğŸ‘‰ You will NOT get notified again.

This is the most important rule.

ğŸ”¥ Visual Example

Assume client sends 100 bytes.

ğŸ”¹ Level Triggered

RX buffer = 100 bytes

epoll_wait â†’ EPOLLIN
You read 50 bytes

RX buffer = 50 bytes

epoll_wait â†’ EPOLLIN again
You read remaining 50

âœ” Safe

ğŸ”¹ Edge Triggered

RX buffer = 100 bytes

epoll_wait â†’ EPOLLIN
You read 50 bytes

RX buffer = 50 bytes

epoll_wait â†’ âŒ Nothing

Because no "new edge" happened.

You missed the remaining 50 bytes.

ğŸ¯ So What Must You Do in Edge Mode?

You must:

Read until recv() returns EAGAIN.

Same for writing.

âœ… Correct Pattern for Edge Triggered
while (true)
{
    ssize_t bytes = recv(fd, buffer, sizeof(buffer), 0);

    if (bytes > 0)
    {
        // Process data
    }
    else if (bytes == -1 && errno == EAGAIN)
    {
        // No more data
        break;
    }
    else
    {
        // Connection closed or error
        close(fd);
        break;
    }
}

ğŸš¨ Golden Rule of Edge Triggered

Always drain the socket completely.

For reading:

recv() until EAGAIN


For writing:

send() until EAGAIN

ğŸ“Œ How To Enable Edge Triggered

When registering fd:

ev.events = EPOLLIN | EPOLLET;
epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &ev);


Also:

âš  Must set socket to NON-BLOCKING.

fcntl(fd, F_SETFL, O_NONBLOCK);


Edge triggered + blocking socket = disaster.

ğŸ”¥ Why Edge Triggered Is Faster

Level triggered:

epoll may repeatedly notify you

More system calls

Edge triggered:

Fewer notifications

Better scalability

Used in high-performance servers

ğŸ§  How Real Redis Works

Real Redis uses:

epoll (on Linux)

Edge triggered mode

Non-blocking sockets

Because it handles thousands/millions of connections efficiently.

ğŸ“Š LT vs ET Comparison
Feature	Level Trigger	Edge Trigger
Easy to use	âœ…	âŒ
Safer	âœ…	âŒ
High performance	Good	Excellent
Requires loop until EAGAIN	Recommended	Mandatory
Used in production servers	Sometimes	Yes
ğŸ”¥ Common Mistake In ET

If you do:

recv(fd, buffer, sizeof(buffer), 0);


only onceâ€¦

You will randomly lose data.

Thatâ€™s the biggest beginner mistake.

ğŸ¯ In Your Redis Project

If you switch to:

EPOLLIN | EPOLLET


You must:

âœ” Set O_NONBLOCK
âœ” Read in loop
âœ” Write in loop
âœ” Handle partial sends

Otherwise your server will behave unpredictably.

ğŸš€ Simple Definition

Edge Triggered epoll:

Notifies you only when buffer state changes from empty â†’ non-empty (or full â†’ non-full).

You must fully drain buffers each time.
